# 函数和作用域

函数也是一个对象，函数中可以封装一些功能（代码），在需要时可以执行这些功能（代码）。

## 基本操作

- 创建函数

  ```js
  var fun = new Function()
  ```

- 执行函数

  ```js
  var fun = new Function()
  func()    //调用函数
  ```

- 使用函数声明来创建函数

  语法：

  ```js
  function 函数名(形参1,形参2,...) {
      语句...
  }
  ```

- 使用函数表达式来创建函数

  语法：

  ```js
  var 函数名 = function(形参1,形参2,...) {
      语句...
  }
  ```

## 参数

- 形参：可以在函数的()中来指定一个或多个形参，多个形参之间用逗号隔开，声明形参就相当于在函数内部声明了对应的变量，但是不赋值。

- 实参：在调用函数时，可以在()中指定实参，实参将会赋值给函数中对应的形参。

调用函数时解析器不会检查实参的类型，所以要注意：是否可能会接受到非法的参数，如果可能，则需要对参数进行类型的检查。

调用函数时，解析器也不会检查实参的数量，多余的实参不会被赋值，如果实参数量少于形参数量，则对应实参的形参会是`undefined`

## 返回值

可以使用`return`来设置函数的返回值，`return`后的值将会作为函数的执行结果返回。可以定义一个变量来接收函数的返回值。

```js
var res = function (a,b) {
    sum = a + b
    return sum
}
```

在函数中`return`后的语句都不会执行。

## 立即执行函数

函数定义完了立即被调用，叫做立即执行函数，往往只会执行依次。

```js
(function (a, b) {
    return sum = a + b
})(2, 3)
```

## 作用域

作用域指一个变量的作用的范围，`js`中有两种作用域：

1. 全局作用域：

   - 直接编写在`script`标签中的`js`代码，都在全局作用域中。
   - 全局作用域在页面打开时创建，在页面关闭时销毁
   - 在全局作用域中有一个全局对象`window`，它代码的是一个浏览器的窗口，它由浏览器创建，可直接使用。
   - 在全局作用域中，创建的变量都会作为`window`对象的属性保存，创建的函数都会作为`window`对象的方法保存。
   - 全局作用域中的变量都是全局变量，在页面的任意部分都可以访问的到。

2. 函数作用域

   - 函数作用域在函数调用时创建函数作用域，函数执行完毕以后，函数作用域销毁

   - 每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的。

   - 函数作用域中可以访问到全局作用域中的变量，但全局作用域中不能访问到函数作用域中的变量。

   - 当在函数作用域中操作一个变量时，会先在自身作用域中寻找，如果有便直接使用，如果没有就往上一级寻找，直到全局作用域，若全局作用域中没有就报错。

   - 在函数作用域中也有声明提前的特性。

   - 在函数中，不使用`var`声明的变量都会变成全局变量

     ```js
     var c = 33
     function fun5() {
         c = 10
     }
     console.log(c)    //10
     ```

## 变量的声明

变量声明提前：使用`var`关键字声明的变量，会在所有的代码执行之前被声明。

```js
console.log(a)      //undefined
var a = 123    
```

函数声明提前：使用函数声明形式创建的函数`function(){}`，会在所有代码执行之前就被创建，所以我们可以在声明前调用函数。

```js
func()    // 1
function func () {
    console.log('1')
} 

func2()    //   报错
var func2 = function(){
    console.log('2')
}        //func2会被提前声明，但是未赋值，所以不能提前调用
```

## this

解析器在调用函数每次都会向函数内部传递一个隐含的参数（`this`），`this`指向的是一个对象，这个对象成为函数执行的上下文对象，根据函数**调用方式**的不同，`this`会指向不同的对象。

1. 以函数的形式调用时，`this`永远都是`window`
2. 以方法的形式调用时，`this`就是调用方法这个对象。
3. 当以构造函数的形式调用时，`this`就是新创建的那个对象。

## 构造函数

构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯首字母大写。

构造函数和普通函数的区别就是调用方式的不同，普通函数是直接调用，而构造函数需要使用`new`关键字来调用。

```js
function Person () {
    
}
var per = new Person()
```

构造函数的执行流程：

1. 立刻创建一个新的对象
2. 将新建的对象设置为函数中的`this`，在构造函数中可以使用`this`来引用新建的对象。
3. 逐行执行函数中的代码
4. 将新建的对象作为返回值返回

使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。我们将通过一个构造函数创建的对象，成为该类的实例。

检测一个对象是否是一个类的实例，可以使用`instanceof`检测。

## 原型对象

创建的每一个函数，解析器都会向函数中添加一个属性`prototype`。这个属性对应着一个对象，这个对象就叫做原型对象。

如果函数作为普通函数调用，`prototype`没有任何作用。

当函数以构造函数形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象。可以通过`__proto__`来访问该属性。

```js
function Person() {
    
}
var per = new Person()
console.log(per.__proto == Person.prototype)
```

原型对象相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。

当我们访问对象中的一个属性或方法时，会先在自身中寻找，如果没有，就会去原型对象中寻找。